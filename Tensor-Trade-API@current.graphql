type ActiveListingPrice {
  owner: String
  price: Decimal!
  source: DataSource!
  tx: LinkedTransactionTV2!
  txAt: Timestamp!
  unit: String!
}

input ActiveListingsCursorInputV2 {
  """
  stringified cursor. Could be object, array, number or string after parsing.
  """
  str: String!
}

type ActiveListingsCursorV2 {
  """
  stringified cursor. Could be object, array, number or string after parsing.
  """
  str: String!
}

input ActiveListingsFilters {
  sources: [DataSource!]
  prices: PriceFilter
  rarities: RarityFilter
  traits: [TraitFilter!]
  traitCount: TraitCountFilter
  nameFilter: String
  ownerFilter: OwnerFilter
  mintsFilter: [String!]
}

type ActiveListingsPageV2 {
  endCursor: ActiveListingsCursorV2
  hasMore: Boolean!
}

type ActiveListingsPricesV2 {
  maxPrice: ActiveListingPrice
  numListed: Int!
  prices: [ActiveListingPrice!]!
}

enum ActiveListingsSortBy {
  LastSaleAsc
  LastSaleDesc
  ListedDesc
  PriceAsc
  PriceDesc
  RankHrttAsc
  RankHrttDesc
  RankStatAsc
  RankStatDesc
  RankTeamAsc
  RankTeamDesc
  RankTnAsc
  RankTnDesc
}

type ActiveListingsV2 {
  page: ActiveListingsPageV2!
  sortBy: ActiveListingsSortBy!
  txs: [LinkedTransactionTV2!]!
}

type AirdropBoxes {
  nftBoxCommon: Int!
  nftBoxEpic: Int!
  nftBoxLegendary: Int!
  nftBoxRare: Int!
  nftBoxUncommon: Int!
  tokenBoxCommon: Int!
  tokenBoxEpic: Int!
  tokenBoxLegendary: Int!
  tokenBoxRare: Int!
  tokenBoxUncommon: Int!
}

type AirdropOne {
  """null if not (yet) claimed"""
  claimedBoxes: AirdropBoxes
  completedAirdrop: Boolean!
  completedBid: Boolean!
  completedListing: Boolean!
  eligibleSpecialBoxes: Boolean!
  totalTensorPoints: Int!
  volume: Int!
}

type AirdropTwoProfileStats {
  """
  This differs from loyaltyLevel on UserProfile in that it's updated async
  """
  loyalty: Int!
  pts24h: Int!
  ptsTotal: Int!
  rank24h: Int!
  rankTotal: Int!
  wallet: String!
}

enum AirdropTwoSortBy {
  By24h
  ByTotal
}

type AllCollections {
  collections: [InstrumentTV2!]!
  page: Int!
  total: Int!
}

"""Whether you want to attach or detach margin"""
enum AttachDetachAction {
  ATTACH
  DETACH
}

type Attribute {
  trait_type: String!
  value: String!
}

input BidsCursorInputV2 {
  """
  Stringified cursor. Could be object, array, number or string after parsing.
  """
  str: String!
}

type BidsCursorV2 {
  """
  Stringified cursor. Could be object, array, number or string after parsing.
  """
  str: String!
}

type BidsPage {
  endCursor: BidsCursorV2
  hasMore: Boolean!
}

enum BidsSortBy {
  PriceAsc
  PriceDesc
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Byte

type CaptchaStatus {
  response: CaptchaWallet!
  valid: Boolean!
}

type CaptchaWallet {
  overrideChecks: Boolean!
  score: Float!
  verifiedAt: Timestamp!
  version: Int!
  wallet: String!
}

type CollInfo {
  floorPrice: Decimal
  name: String!
  numMints: Int
  slug: String!
}

type CollectionFavorite {
  favList: Int!
  profileId: String!
  slug: String!
}

type CollectionHolder {
  numListed: Int!
  numOwned: Int!
  wallet: String!
}

type CollectionHolderStats {
  topHolders: [CollectionHolder!]!
  uniqueHolders: Int!
  updatedAt: Timestamp!
}

type CollectionMints {
  mints: [LinkedTxMintTV2!]!
  page: CollectionMintsPage!
}

input CollectionMintsFilters {
  rarities: RarityFilter
  traits: [TraitFilter!]
  traitCount: TraitCountFilter
  nameFilter: String

  """filter for only NFTs that are listed for sale"""
  onlyListings: Boolean

  """filter for listings from specific data sources"""
  listingSources: [DataSource!]
  listingPrices: PriceFilter

  """TODO: doesn't work for unlisted regular NFTs"""
  ownerFilter: OwnerFilter
  mintsFilter: [String!]
}

type CollectionMintsPage {
  endCursor: Int
  hasMore: Boolean!
  total: Int
}

enum CollectionMintsSortBy {
  LastSaleAsc
  LastSaleDesc
  ListedTimeDesc
  ListingPriceAsc
  ListingPriceDesc
  RankHrttAsc
  RankHrttDesc
  RankStatAsc
  RankStatDesc
  RankTeamAsc
  RankTeamDesc
  RankTnAsc
  RankTnDesc
}

type CollectionMintsV2 {
  mints: [MintWithTx!]!
  page: CollectionMintsV2Page!
}

type CollectionMintsV2Page {
  endCursor: String
  hasMore: Boolean!
}

type CollectionStats {
  floor1h: Float
  floor24h: Float
  floor7d: Float
  floorPrice: Decimal
  marketCap: Decimal
  numListed: Float!
  numMints: Float!
  pctListed: Float
  priceUnit: Currency!
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
}

type CollectionStatsSwap implements ICollectionStatsSwap {
  buyNowPrice: Decimal
  nftsForSale: Float!
  priceUnit: Currency!
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  sellNowPrice: Decimal
  solDeposited: Decimal!
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
}

type CollectionStatsTSwap implements ICollectionStatsSwap {
  buyNowPrice: Decimal
  nftsForSale: Float!
  numMints: Float!
  priceUnit: Currency!
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  sellNowPrice: Decimal
  solDeposited: Decimal!
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
}

type CollectionStatsV2 {
  """null means no listings"""
  buyNowPrice: Decimal

  """includes fees and royalties"""
  buyNowPriceNetFees: Decimal
  currency: String
  floor1h: Float
  floor24h: Float
  floor7d: Float
  marketCap: Decimal
  numBids: Float!
  numListed: Float!
  numMints: Float!
  pctListed: Float
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  salesAll: Int!

  """null means no bids"""
  sellNowPrice: Decimal

  """includes fees and royalties"""
  sellNowPriceNetFees: Decimal
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
  volumeAll: Decimal!
}

type CollectionTraitsRarities {
  numMints: Int!
  rarityAlgos: [String!]! @deprecated(reason: "use traitMeta.raritySystems")
  raritySystems: [RaritySystem!]!
  traitActive: JSON
  traitMeta: JSON!
}

type ConfirmMeAuthResponse {
  exp: Float!
  id: String!
  token: String!
}

"""The currency of the associated price amount(s)"""
enum Currency {
  ETH_WEI
  SOL_LAMPORT
}

enum CurveType {
  EXPONENTIAL
  LINEAR
  XYK
}

enum DataSource {
  ALPHA
  AUCTION_HOUSE
  BUBBLEGUM
  DIGITALEYEZ
  DIGITALEYEZ_V2
  ELIXIR
  ELIXIR_COMPOSED
  HADESWAP
  HYPERSPACE
  MAGICEDEN
  MAGICEDEN_AUCTION
  MAGICEDEN_V2
  ONCHAIN
  SMB
  SMB_V2
  SOLANART
  SOLSEA
  TCOMP
  TENSORBID
  TENSORSWAP
  TOKEN_METADATA
  YAWWW
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

"""Whether you want to deposit or withdraw NFT or SOL"""
enum DepositWithdrawAction {
  DEPOSIT
  WITHDRAW
}

type ElixirPool {
  address: String!
  baseDecimals: Float!
  baseLiquidity: String!
  buyPrices: [Float!]!
  createdAt: Timestamp!
  pNftMint: String!
  quoteDecimals: Float!
  quoteLiquidity: String!
  sellPrices: [Float!]!
  vaults: [ElixirVault!]!
}

type ElixirPoolUpdate {
  address: String!
  pool: ElixirPool
}

type ElixirVault {
  address: String!
  fNftMint: String!
  mint: LinkedTxMintTV2!
  mintAta: String!
}

type FavMintsAllSlugs {
  mints: [MintWithColl!]!
  page: FavMintsAllSlugsPage!
}

type FavMintsAllSlugsPage {
  endCursor: String
  hasMore: Boolean!
  total: Int
}

type FeaturedCollection {
  banner: String!
  dateExpires: Timestamp
  dateLaunches: Timestamp!
  discord: String
  hidden: Boolean!
  id: String!
  launchpadUrl: String
  multiplier: Decimal!
  name: String!
  ordinal: Int!
  parsed: InstrumentTV2
  readyToTrade: Boolean!
  slug: String!
  subtitle: String!
  twitter: String
  website: String
}

type FeeInfo {
  bps: Int!
  kind: String!
}

enum HSwapCurveType {
  Exponential
  Linear
  XYK
}

input HSwapModifyPairConfig {
  spotPrice: Decimal!
  delta: Decimal!
  feeBps: Int
}

type HSwapNftBox {
  address: String!
  mint: LinkedTxMintTV2!
  pair: String!
  vaultTokenAccount: String!
}

input HSwapPairConfig {
  spotPrice: Decimal!
  delta: Decimal!
  feeBps: Int
  pairType: HSwapPairType!
  curveType: HSwapCurveType!
}

enum HSwapPairType {
  LiquidityProvision
  NftForToken
  TokenForNFT
}

type HSwapPool {
  address: String!
  assetReceiver: String!
  baseSpotPrice: BigInt!
  boxes: [HSwapNftBox!]!
  buyOrdersQuantity: Int!

  """only an approx: first time this PDA was ingested"""
  createdAt: Timestamp!
  curveType: CurveType!
  delta: BigInt!
  feeBalance: Decimal
  feeBps: Int!
  fundsSolOrTokenBalance: BigInt!
  lastTransactedAt: Timestamp!
  mathCounter: Int!
  pairType: PoolType!
}

type HSwapPoolUpdate {
  address: String!
  pool: HSwapPool
}

type HSwapPoolWithColl {
  collName: String!
  floorPrice: Decimal
  numMints: Int
  pool: HSwapPool!
  slug: String!
}

interface ICollectionStatsSwap {
  buyNowPrice: Decimal
  nftsForSale: Float!
  priceUnit: Currency!
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  sellNowPrice: Decimal
  solDeposited: Decimal!
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
}

type InitEditPoolTxResponse {
  pool: String!
  txs: [OnchainTx!]!
}

type InitPairTxResponse {
  authAdapter: String!
  pair: String!
  txs: [OnchainTx!]!
}

type InstrumentForPortfolio {
  bidCount: Float!
  compressed: Boolean!
  createdAt: Timestamp!
  description: String
  discord: String
  favCount: Float!
  firstListDate: Timestamp
  hidden: Boolean!
  hswapTVL: Decimal @deprecated(reason: "no longer tracked")

  """if hadeswap supports this collection"""
  hswapWhitelisted: Boolean!
  id: String!
  imageUri: String
  listedCount: Float!
  mintCount: Float!
  name: String!
  sellRoyaltyFeeBPS: Int
  slug: String!
  slugDisplay: String
  slugMe: String
  slugOs: String @deprecated(reason: "no longer used")
  stats: CollectionStats @deprecated(reason: "Please use statsV2")
  statsHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsOverall: CollectionStats @deprecated(reason: "Please use statsV2")
  statsSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTSwap: CollectionStatsTSwap @deprecated(reason: "Please use statsV2")
  statsV2: CollectionStatsV2
  swapTVL: Decimal @deprecated(reason: "no longer tracked")
  symbol: String

  """unsupported on all Tensor protocols (eg OCP/creator disabled)"""
  tensorUnsupported: Boolean
  tensorVerified: Boolean!

  """
  if we have whitelisted this collection already for collection-wide bids + pools
  """
  tensorWhitelisted: Boolean!
  thswapTVL: Decimal @deprecated(reason: "no longer tracked")
  tokenStandard: TokenStandard
  traits: CollectionTraitsRarities
  tswapTVL: Decimal @deprecated(reason: "no longer tracked")
  twitter: String
  website: String
}

type InstrumentTV2 {
  compressed: Boolean!
  createdAt: Timestamp!
  description: String
  discord: String
  firstListDate: Timestamp
  hidden: Boolean!
  hswapTVL: Decimal @deprecated(reason: "no longer tracked")

  """if hadeswap supports this collection"""
  hswapWhitelisted: Boolean!
  id: String!
  imageUri: String
  name: String!
  sellRoyaltyFeeBPS: Int
  slug: String!
  slugDisplay: String
  slugMe: String
  slugOs: String @deprecated(reason: "no longer used")
  stats: CollectionStats @deprecated(reason: "Please use statsV2")
  statsHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsOverall: CollectionStats @deprecated(reason: "Please use statsV2")
  statsSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTSwap: CollectionStatsTSwap @deprecated(reason: "Please use statsV2")
  statsV2: CollectionStatsV2
  swapTVL: Decimal @deprecated(reason: "no longer tracked")
  symbol: String

  """unsupported on all Tensor protocols (eg OCP/creator disabled)"""
  tensorUnsupported: Boolean
  tensorVerified: Boolean!

  """
  if we have whitelisted this collection already for collection-wide bids + pools
  """
  tensorWhitelisted: Boolean!
  thswapTVL: Decimal @deprecated(reason: "no longer tracked")
  tokenStandard: TokenStandard
  traits: CollectionTraitsRarities
  tswapTVL: Decimal @deprecated(reason: "no longer tracked")
  twitter: String
  website: String
}

type InstrumentWithMints {
  compressed: Boolean!
  createdAt: Timestamp!
  description: String
  discord: String
  firstListDate: Timestamp
  hidden: Boolean!
  hswapTVL: Decimal @deprecated(reason: "no longer tracked")

  """if hadeswap supports this collection"""
  hswapWhitelisted: Boolean!
  id: String!
  imageUri: String
  mintCount: Float!
  mints: [MintWithColl!]
  name: String!
  sellRoyaltyFeeBPS: Int
  slug: String!
  slugDisplay: String
  slugMe: String
  slugOs: String @deprecated(reason: "no longer used")
  stats: CollectionStats @deprecated(reason: "Please use statsV2")
  statsHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsOverall: CollectionStats @deprecated(reason: "Please use statsV2")
  statsSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTHSwap: CollectionStatsSwap @deprecated(reason: "Please use statsV2")
  statsTSwap: CollectionStatsTSwap @deprecated(reason: "Please use statsV2")
  statsV2: CollectionStatsV2
  swapTVL: Decimal @deprecated(reason: "no longer tracked")
  symbol: String

  """unsupported on all Tensor protocols (eg OCP/creator disabled)"""
  tensorUnsupported: Boolean
  tensorVerified: Boolean!

  """
  if we have whitelisted this collection already for collection-wide bids + pools
  """
  tensorWhitelisted: Boolean!
  thswapTVL: Decimal @deprecated(reason: "no longer tracked")
  tokenStandard: TokenStandard
  traits: CollectionTraitsRarities
  tswapTVL: Decimal @deprecated(reason: "no longer tracked")
  twitter: String
  website: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type LastSale implements TLastSale {
  price: Decimal!
  priceUnit: Currency!
  txAt: Timestamp!
}

type LinkedTransactionMintWithColl {
  mint: MintWithColl!
  tx: ParsedTransaction!
}

type LinkedTransactionTV2 {
  mint: LinkedTxMintTV2!
  tx: ParsedTransaction!
}

type LinkedTxMintTV2 implements TLinkedTxMintTV2 {
  accState: String
  animationUri: String
  attributes: JSON
  compressed: Boolean!
  imageUri: String
  lastSale: LastSale
  metadataFetchedAt: Timestamp
  metadataUri: String
  name: String
  onchainId: String!
  owner: String
  rarityRankHR: Int
  rarityRankStat: Int
  rarityRankTN: Int
  rarityRankTT: Int
  rarityRankTTCustom: Int
  rarityRankTTStat: Int
  rarityRankTeam: Int
  sellRoyaltyFeeBPS: Int
  tokenEdition: Int
  tokenStandard: TokenStandard
  verifiedCollection: String
}

type MEWalletProfile {
  meVerified: Boolean!
  wallet: String!
}

type MadBox {
  entries: Int!
  from: Timestamp!
  to: Timestamp!
  week: Int!

  """if null, means winners havent't been chosen yet"""
  winner: Boolean
}

type MintBid {
  bidder: String
  expiry: Timestamp
  margin: String
  mint: MintWithColl!
  mp: SupportedMarketplace!
  price: Decimal!
  validFrom: Timestamp
}

type MintFavorite {
  favList: Int!
  mint: String!
  profileId: String!
}

type MintV2 {
  accState: String
  animationUri: String
  attributes: [Attribute!]
  compressed: Boolean!
  imageUri: String
  lastSale: LastSale
  metadataFetchedAt: Timestamp
  metadataUri: String
  name: String
  onchainId: String!
  owner: String
  rarityRankHR: Int
  rarityRankStat: Int
  rarityRankTN: Int
  rarityRankTT: Int
  rarityRankTTCustom: Int
  rarityRankTTStat: Int
  rarityRankTeam: Int
  sellRoyaltyFeeBPS: Int
  tokenEdition: Int
  tokenStandard: TokenStandard
  verifiedCollection: String
}

type MintWithColl implements TLinkedTxMintTV2 {
  accState: String
  activeListings: [LinkedTransactionTV2!]!
  animationUri: String
  attributes: JSON
  collId: String!
  collName: String!
  collection: InstrumentTV2
  compressed: Boolean!
  hswapOrders: [HSwapPool!]!
  imageUri: String
  lastSale: LastSale
  metadataFetchedAt: Timestamp
  metadataUri: String
  name: String
  numMints: Int
  onchainId: String!
  owner: String
  rarityRankHR: Int
  rarityRankStat: Int
  rarityRankTN: Int
  rarityRankTT: Int
  rarityRankTTCustom: Int
  rarityRankTTStat: Int
  rarityRankTeam: Int
  sellRoyaltyFeeBPS: Int
  slug: String!
  slugDisplay: String
  tcompBids: [TCompBid!]!
  tensorBids(bestSellNowOnly: Boolean, limit: Int, sortBy: OrderSortBy): [MintBid!]
  tokenEdition: Int
  tokenStandard: TokenStandard
  tswapOrders(limit: Int, sortBy: OrderSortBy): [TSwapPool!]!
  verifiedCollection: String
}

type MintWithTx {
  mint: MintV2!
  tx: ParsedTransaction
}

type MpFees {
  makerFeeBps: Float!
  mp: SupportedMarketplace!
  takerFeeBps: Float!
  takerRoyalties: Boolean!
}

type Mutation {
  addFavCollection(favList: Int, jwt: String!, slug: String!): String!
  addFavMint(favList: Int, jwt: String!, mint: String!): String!
  addFavWallet(favList: Int, jwt: String!, wallet: String!): String!
  claimAirdropOne(jwt: String!): UserProfile!
  discordAuthenticate(code: String!, jwt: String!, state: String!): UserProfile!
  discordVerifyJoin(jwt: String!): UserProfile
  emailVerifyBegin(domain: String!, email: String!, jwt: String!): UserProfile!
  emailVerifyComplete(code: String!, jwt: String!): UserProfile!
  linkUserProfileV2(
    """jwt related to the PARENT profile"""
    jwt: String!

    """goes together with the memo tx"""
    lastValidBlockHeight: Int

    """memo tx signed by the CHILD wallet (use for ledger)"""
    memoTx: [Int!]

    """signature by the CHILD wallet"""
    signatureBase58: String

    """CHILD wallet"""
    wallet: String!
  ): UserProfile
  removeFavCollection(favList: Int, jwt: String!, slug: String!): String!
  removeFavMint(favList: Int, jwt: String!, mint: String!): String!
  removeFavWallet(favList: Int, jwt: String!, wallet: String!): String!
  sendUserTransaction(action: String!, amounts: [Decimal!], data: UserTxDataInput!, lastValidBlockHeight: Int, mints: [String!], mp: SupportedMarketplace!, poolAddresses: [String!], serializedTx: [Int!]!, txMpMetadata: JSON, txVersion: Int, wallet: String!): String!
  setBidNotifMinPctFloor(jwt: String!, minPctFloor: Int!): Int!
  twitterApiV1Authenticate(jwt: String!, oauth_token: String!, oauth_verifier: String!): UserProfile!
  twitterApiV1VerifyFollow(jwt: String!): UserProfile
  twitterApiV2Authenticate(code: String!, jwt: String!, state: String!): UserProfile!
  unlinkUserProfileV2(jwt: String!, wallet: String!): UserProfile
  updateUserProfile(jwt: String!, username: String, wallet: String!): UserProfile!
  verifyCaptcha(signatureBase58: String!, wallet: String!): CaptchaStatus!
  verifyCreateUserProfileV2(
    """goes together with the memo tx"""
    lastValidBlockHeight: Int

    """memo tx signed by the wallet (use for ledger)"""
    memoTx: [Int!]

    """signature by the wallet"""
    signatureBase58: String
    wallet: String!
  ): UserProfileWithJwtV2!
}

type OnchainTx {
  lastValidBlockHeight: Int
  metadata: JSON

  """only present if fits into size"""
  tx: Byte
  txV0: Byte!
}

enum OrderSortBy {
  SellNowPriceDesc
}

type OverallStatsSwap {
  nftsForSale: Float!
  priceUnit: Currency!
  sales1h: Int!
  sales24h: Int!
  sales7d: Int!
  solDeposited: Decimal!
  volume1h: Decimal!
  volume24h: Decimal!
  volume7d: Decimal!
}

input OwnerFilter {
  include: [String!]
  exclude: [String!]
}

type PaginatedTransactions {
  page: TransactionsPage!
  txs: [LinkedTransactionTV2!]!
}

type PaginatedTransactionsWithColl {
  page: TransactionsPage!
  txs: [LinkedTransactionMintWithColl!]!
}

type PaginatedUserTransactions {
  page: TransactionsPage!
  txs: [UserTransaction!]!
}

type ParsedTransaction {
  blockNumber: BigInt!
  buyerId: String
  grossAmount: Decimal
  grossAmountUnit: String
  keyVersion: Float!
  listingEnd: Timestamp
  mintOnchainId: String!
  poolOnchainId: String
  sellerId: String
  source: DataSource!
  txAt: Timestamp!
  txId: String!
  txKey: String!
  txMetadata: TxMetadata
  txType: TransactionType!
}

input PoolConfig {
  poolType: PoolType!
  curveType: CurveType!
  startingPrice: Decimal!
  delta: Decimal!
  mmCompoundFees: Boolean
  mmFeeBps: Int
}

enum PoolType {
  NFT
  TOKEN
  TRADE
}

input PriceFilter {
  min: Decimal
  max: Decimal
}

type Query {
  """
  Returns the lowest priced active listing for each mint in the collection. `filters.source` is ignored.
  """
  activeListingsPricesV2(filters: ActiveListingsFilters, slug: String!): ActiveListingsPricesV2!
  activeListingsV2(cursor: ActiveListingsCursorInputV2, filters: ActiveListingsFilters, limit: Int = 250, slug: String!, sortBy: ActiveListingsSortBy!): ActiveListingsV2!
  airdropTwoLeaderboard(sortBy: AirdropTwoSortBy!): [AirdropTwoProfileStats!]!

  """Only available in API mode!"""
  allCollections(ids: [String!], limit: Int = 100, page: Int = 1, slugs: [String!], slugsDisplay: [String!], slugsMe: [String!], sortBy: String = "statsOverall.volume24h:desc"): AllCollections!
  allMeBids(wallet: String!): [MintBid!]!

  """Fetches all NFT transactions for wallet, listing AND swap."""
  allUserTransactionsV2(cursor: TransactionsCursorInput, filters: TransactionsFilters, limit: Int = 100, slug: String, wallets: [String!]!): PaginatedTransactionsWithColl!
  bidTx(bidder: String!, expireIn: Float, marginNr: Float, mint: String!, price: Decimal!): TxResponse!
  cancelBidTx(bidder: String!, mint: String!): TxResponse!
  captchaStatus(wallet: String!): CaptchaStatus
  collectionHolderStats(slug: String!): CollectionHolderStats
  collectionMints(cursor: Int = 0, filters: CollectionMintsFilters, limit: Int = 100, slug: String!, sortBy: CollectionMintsSortBy!): CollectionMints! @deprecated(reason: "Use collectionMintsV2 instead.")
  collectionMintsV2(cursor: String, filters: CollectionMintsFilters, limit: Int = 250, slug: String!, sortBy: CollectionMintsSortBy!): CollectionMintsV2!
  discordRedirectUrl(callbackUrl: String!, jwt: String!): String!
  elixirBuyNftTx(buyer: String!, maxLamports: String!, mint: String!): TxResponse!
  elixirOrderTransactions(address: String!, cursor: TransactionsCursorInput, limit: Int = 100): PaginatedTransactions!
  elixirOrders(slug: String!): [ElixirPool!]!
  elixirSellNftTx(minLamports: String!, mint: String!, seller: String!, slug: String!): TxResponse!
  favMintsAllSlugs(cursor: String, favList: Int = 1, jwt: String!, limit: Int = 100): FavMintsAllSlugs!
  favMintsBySlug(favList: Int, jwt: String!, slug: String!): [MintFavorite!]!
  featuredCollections: [FeaturedCollection!]!
  getMeAuth(wallet: String!): ConfirmMeAuthResponse
  getMemoTxToSign(wallet: String!): TxResponse!
  getMessageToSign(msgType: SignMsgType!, wallet: String!): String!
  globalVol: String
  hswapBuyNftTx(buyer: String!, mathCounter: Float, maxPriceLamports: Decimal!, mint: String!, pair: String!): TxResponse!
  hswapClosePairTx(pair: String!): TxResponse!
  hswapDepositWithdrawBalancedLiquidityTx(
    action: DepositWithdrawAction!

    """If not provided, will look up in index for pair."""
    authAdapter: String
    mint: String!
    owner: String!
    pair: String!
  ): TxResponse! @deprecated(reason: "see hswapDepositWithdrawBuyOrdersTx and hswapDepositWithdrawSellOrdersTx")
  hswapDepositWithdrawBuyOrdersTx(
    action: DepositWithdrawAction!

    """If not provided, will look up in index for pair."""
    authAdapter: String
    buyOrders: Int!
    owner: String!
    pair: String!
  ): TxResponse!
  hswapDepositWithdrawNftTx(
    action: DepositWithdrawAction!

    """If not provided, will look up in index for pair."""
    authAdapter: String
    mint: String!
    owner: String!
    pair: String!
  ): TxResponse!
  hswapDepositWithdrawSellOrderTx(
    action: DepositWithdrawAction!

    """If not provided, will look up in index for pair."""
    authAdapter: String
    mint: String!
    owner: String!
    pair: String!
  ): TxResponse!
  hswapDepositWithdrawSolTx(
    action: DepositWithdrawAction!

    """If not provided, will look up in index for pair."""
    authAdapter: String
    buyOrdersQuantity: Int!
    owner: String!
    pair: String!
  ): TxResponse!
  hswapExchangeNftTx(
    """max price for the buy tx (should the current sell price)"""
    maxPriceLamports: Decimal!

    """min price for the sell tx (should the current sell price - 2x MM fee)"""
    minPriceLamports: Decimal!
    mintToBuy: String!
    mintToSell: String!
    pair: String!
    taker: String!
  ): TxResponse!
  hswapInitPairTx(authKpSecretBase64: String, config: HSwapPairConfig!, owner: String!, pairKpSecretBase64: String, slug: String!): InitPairTxResponse!
  hswapModifyPairTx(config: HSwapModifyPairConfig!, pair: String!): TxResponse!
  hswapOrderTransactions(address: String!, cursor: TransactionsCursorInput, limit: Int = 100): PaginatedTransactions!
  hswapOrders(
    """If owner is specified, also returns the empty pools of the owner"""
    owner: String
    slug: String!
  ): [HSwapPool!]!
  hswapSellNftTx(mathCounter: Float, minPriceLamports: Decimal!, mint: String!, pair: String!, seller: String!): TxResponse!

  """This withdraws 2 buy orders worth of SOL at a time from an LP pair."""
  hswapWithdrawBuyLiquidityTx(pair: String!): TxResponse! @deprecated(reason: "see hswapDepositWithdrawBuyOrdersTx")
  hswapWithdrawFeesTx(pair: String!): TxResponse!

  """This withdraws 2 NFTs at a time from an LP pair."""
  hswapWithdrawSellLiquidityTx(mint1: String!, mint2: String!, pair: String!): TxResponse! @deprecated(reason: "see hswapDepositWithdrawSellOrdersTx")
  hyperspaceBuyNftTx(buyer: String!, mint: String!, optionalRoyaltyBps: Int, priceLamports: Decimal!, seller: String): TxResponse!
  instrumentTV2(slug: String!): InstrumentTV2

  """
  returns inventory info (unverified mints will be under the catch-all UNVERIFIED collection)
  """
  inventoryBySlug(
    includeCompressed: Boolean = true
    includeFrozen: Boolean
    includeUnverified: Boolean
    owner: String!

    """
    Which slugs to also retrieve actual mints for: if set to null, retrieves all mints.
    """
    slugsToInflate: [String!]
  ): [InstrumentWithMints!]!
  meAuthEnabled: Boolean!
  meBids(slug: String!, wallet: String!): [MintBid!]!
  meBuyNftTx(buyer: String!, mint: String!, optionalRoyaltyPct: Int, priceLamports: Decimal!, seller: String): TxResponse!
  meDelistNftTx(mint: String!, priceLamports: Decimal!, seller: String!): TxResponse!

  """
  returns mint with collection details (unverified and verified collections included)
  """
  mint(mint: String!): MintWithColl
  mintList(after: String, limit: Int = 10000, slug: String!): [String!]!
  mintListTSwap(slug: String!): [String!]! @deprecated(reason: "Use mintList instead.")
  mintTensorBids(maxCount: Float, mint: String!): [MintBid!]!
  mintTransactions(cursor: TransactionsCursorInput, filters: TransactionsFilters, limit: Int = 100, mint: String!): PaginatedTransactions!

  """
  returns all mints with collection details (unverified and verified collections included)
  """
  mints(tokenMints: [String!]!): [MintWithColl!]!
  mpFees(owner: String): [MpFees!]!
  overallStatsTSwap: OverallStatsSwap
  recentTransactions(
    cursor: TransactionsCursorInput
    filters: TransactionsFilters

    """
    Shows only the latest listing/delist for a given NFT mint in the txs feed
    """
    keepLatestListDelistOnly: Boolean = false
    limit: Int = 100
    slug: String!
  ): PaginatedTransactions!
  serviceStatuses: [ServiceStatus!]!
  solanaTps: Int!
  solanartBuyNftTx(buyer: String!, mint: String!, priceLamports: Decimal!, seller: String!): TxResponse!
  takeBidTx(bidder: String!, mint: String!, optionalRoyaltyPct: Int, price: Decimal!, seller: String!): TxResponse!
  tcompBidTransactions(address: String!, cursor: TransactionsCursorInput, limit: Int = 100): PaginatedTransactions!
  tcompBidTx(
    depositLamports: Decimal
    expireIn: Float
    field: TCompField
    fieldId: String
    marginNr: Float
    owner: String!
    price: Decimal!
    privateTaker: String
    quantity: Float!

    """
    eithr target + targetId must be passed or slug. If slug is passed, it takes precedence
    """
    slug: String
    target: TCompTarget

    """token mint or whitelist"""
    targetId: String

    """tops up margin with missing amount so it has enough to fill the bid"""
    topUpMarginWhenBidding: Boolean = true
  ): TxResponse!
  tcompBids(
    filters: TCompBidsFilters

    """If owner is specified, also returns the empty bids of the owner"""
    owner: String
    slug: String!
  ): [TCompBid!]!
  tcompBuyTx(buyer: String!, maxPrice: Decimal!, mint: String!, optionalRoyaltyPct: Int, owner: String!, payer: String): TxResponse!
  tcompCancelBidTx(mint: String!, owner: String!): TxResponse!
  tcompCancelCollBidTx(bidStateAddress: String!): TxResponse!
  tcompDelistTx(mint: String!, owner: String!): TxResponse!
  tcompEditBidTx(attachDetachMargin: AttachDetachAction, bidStateAddress: String!, expireIn: Float, marginNr: Float, price: Decimal, privateTaker: String, quantity: Float): TxResponse!
  tcompEditTx(expireIn: Float, mint: String!, owner: String!, price: Decimal!, privateTaker: String): TxResponse!
  tcompListTx(delegateSigner: Boolean, expireIn: Float, mint: String!, owner: String!, payer: String, price: Decimal!, privateTaker: String): TxResponse!
  tcompTakeBidTx(bidStateAddress: String, buyer: String, delegateSigner: Boolean, minPrice: Decimal!, mint: String!, optionalRoyaltyPct: Int, seller: String!): TxResponse!
  tcompTransferTx(from: String!, mint: String!, to: String!): TxResponse!
  traits(slug: String!): CollectionTraitsRarities
  tswapAttachPoolMarginAccountTx(config: PoolConfig!, marginNr: Float!, owner: String!, whitelist: String!): TxResponse!
  tswapBuyNftTx(buyer: String!, maxPriceLamports: Decimal!, mint: String!, optionalRoyaltyPct: Int, pool: String!): TxResponse!
  tswapBuySingleListingTx(buyer: String!, maxPrice: Decimal!, mint: String!, optionalRoyaltyPct: Int, owner: String!): TxResponse!
  tswapCloseMarginAccountTx(marginNr: Float!, owner: String!): TxResponse!
  tswapClosePoolTx(pool: String!): TxResponse!
  tswapDelistNftTx(mint: String!, owner: String!, payer: String): TxResponse!
  tswapDepositWithdrawMarginAccountTx(action: DepositWithdrawAction!, lamports: Decimal!, marginNr: Float!, owner: String!): TxResponse!

  """
  This differs from the non-Raw version by not requiring our backend to have indexed the pool address
  """
  tswapDepositWithdrawNftRawTx(
    action: DepositWithdrawAction!
    config: PoolConfig!

    """
    A tswap deposit consists of (1) proof ix and (2) deposit ix. Keeping this boolean as true returns (1) as well as (2), otherwise only (2) is returned.
    """
    includeProof: Boolean = true
    mint: String!
    owner: String!
    whitelist: String!
  ): TxResponse!
  tswapDepositWithdrawNftTx(
    action: DepositWithdrawAction!

    """
    A tswap deposit consists of (1) proof ix and (2) deposit ix. Keeping this boolean as true returns (1) as well as (2), otherwise only (2) is returned.
    """
    includeProof: Boolean = true
    mint: String!
    pool: String!
  ): TxResponse!

  """
  This differs from the non-Raw version by not requiring our backend to have indexed the pool address
  """
  tswapDepositWithdrawSolRawTx(action: DepositWithdrawAction!, config: PoolConfig!, lamports: Decimal!, owner: String!, whitelist: String!): TxResponse!
  tswapDepositWithdrawSolTx(action: DepositWithdrawAction!, lamports: Decimal!, pool: String!): TxResponse!
  tswapDetachPoolMarginAccountTx(config: PoolConfig!, marginNr: Float!, owner: String!, whitelist: String!): TxResponse!
  tswapEditPoolTx(attachDetachMargin: AttachDetachAction, marginNr: Float, maxTakerSellCount: Float, newConfig: PoolConfig, pool: String!): InitEditPoolTxResponse!
  tswapEditSingleListingTx(mint: String!, owner: String!, price: Decimal!): TxResponse!
  tswapExchangeNftTx(
    """
    A tswap sell consists of (1) proof ix and (2) sell ix. Keeping this boolean as true returns (1) as well as (2), otherwise only (2) is returned.
    """
    includeProof: Boolean = true

    """max price for the buy tx"""
    maxPriceLamports: Decimal!

    """min price for the sell tx"""
    minPriceLamports: Decimal!
    mintToBuy: String!
    mintToSell: String!
    pool: String!
    taker: String!
  ): TxResponse!
  tswapInitMarginAccountTx(desiredNr: Float, name: String!, owner: String!): TxResponse!
  tswapInitPoolTx(
    config: PoolConfig!
    depositLamports: Decimal
    marginNr: Float
    maxTakerSellCount: Float

    """
    optional mint for which to init/update proof. Useful when creating a LIST pool with a single mint, to combine 2 txs (init pool & init proof) into one.
    """
    mintForProof: String
    owner: String!
    slug: String!

    """tops up margin with missing amount so it has enough to fill the bid"""
    topUpMarginWhenBidding: Boolean = true
  ): InitEditPoolTxResponse!
  tswapInitUpdateProofTx(mint: String!, payer: String!, whitelist: String!): TxResponse!
  tswapListNftTx(mint: String!, owner: String!, ownerTokenAccount: String, payer: String, price: Decimal!): TxResponse!
  tswapMarginAccounts(owner: String!): [TSwapMarginAccount!]!
  tswapMintProofs(mints: [String!]!, whitelist: String!): [TSwapMintProof!]!
  tswapOrderTransactions(address: String!, cursor: TransactionsCursorInput, limit: Int = 100): PaginatedTransactions!
  tswapOrders(
    """If owner is specified, also returns the empty pools of the owner"""
    owner: String
    slug: String!
  ): [TSwapPool!]!
  tswapSellNftTx(
    """
    A tswap sell consists of (1) proof ix and (2) sell ix. Keeping this boolean as true returns (1) as well as (2), otherwise only (2) is returned.
    """
    includeProof: Boolean = true
    minPriceLamports: Decimal!
    mint: String!
    optionalRoyaltyPct: Int
    pool: String!
    seller: String!

    """
    If provided, will generate ix withdrawing NFT from this account vs the current token account
    """
    sellerTokenAccount: String
  ): TxResponse!
  tswapWhitelist(slug: String!): TSwapWhitelist
  tswapWithdrawMmFeeTx(lamports: Decimal!, pool: String!): TxResponse!
  twitterApiV1RedirectUrl(callbackUrl: String!, jwt: String!): String!
  twitterApiV2RedirectUrl(callbackUrl: String!, jwt: String!): String!
  userActiveListingsV2(cursor: ActiveListingsCursorInputV2, includeCompressed: Boolean = true, limit: Int = 10000, slug: String, sortBy: ActiveListingsSortBy!, wallets: [String!]!): UserActiveListingsV2!
  userEscrowedBidCount(wallet: String!): Float!
  userHswapOrders(owner: String!): [HSwapPoolWithColl!]!
  userPortfolioBids(filterOutOwn: Boolean, includeCompressed: Boolean = true, includeUnverified: Boolean, slug: String, wallets: [String!]!): [MintBid!]!
  userPortfolioCollections(includeCompressed: Boolean = true, includeUnverified: Boolean, wallets: [String!]!): [InstrumentForPortfolio!]!
  userProfileV2(jwt: String!, wallet: String!): UserProfile
  userSentTransactionStats(wallets: [String!]!): UserSentTransactionStats!

  """Fetches transactions for wallet that were sent through Tensor."""
  userSentTransactions(cursor: TransactionsCursorInput, filters: TransactionsFilters, limit: Int = 100, slug: String, wallets: [String!]!): PaginatedUserTransactions!
  userTcompBids(filters: TCompBidsFilters, owner: String!): [TCompBidWithColl!]!
  userTensorBids(filterFunded: Boolean, slug: String, wallet: String!): [MintBid!]! @deprecated(reason: "use `userTensorBidsV2` instead")
  userTensorBidsV2(cursor: BidsCursorInputV2, filterFunded: Boolean!, limit: Int = 500, nameFilter: String, slug: String, sortBy: BidsSortBy!, wallet: String!): TensorBidsV2!
  userTswapOrders(owner: String!): [TSwapPoolWithColl!]!
  walletProfile(wallet: String!): MEWalletProfile
}

input RarityFilter {
  min: Int
  max: Int
  system: RaritySystem!
}

enum RaritySystem {
  Hrtt
  Stat
  Team
  Tn
}

type SentTransactionStats {
  failed: Int!
  pending: Int!
  success: Int!
}

type ServiceStatus {
  numConsecutive: Int!
  service: String!
  status: String!
  updatedAt: Timestamp!
}

"""What type of msg to sign for wallet verification"""
enum SignMsgType {
  LINK
  VERIFY
}

type Subscription {
  elixirOrderUpdate(slug: String!): ElixirPoolUpdate
  hswapOrderUpdate(slug: String!): HSwapPoolUpdate
  newTransactionTV2(slug: String!): LinkedTransactionTV2
  newUserTransaction(limit: Int, wallet: String!): UserTransaction
  tcompBidUpdate(slug: String!): TCompBidUpdate
  tcompBidUpdateAll: TCompBidUpdateAll
  tswapMarginUpdate(owner: String!): TSwapMarginUpdate
  tswapOrderUpdate(slug: String!): TSwapPoolUpdate
  tswapOrderUpdateAll: TSwapPoolUpdateAll
}

enum SupportedMarketplace {
  CoralCube
  Elixir
  Fractal
  HadeSwap
  HyperSpace
  MagicEden
  OpenSea
  Solanart
  SolanartAH
  TComp
  TensorSwap
  Yawww
}

type TCompBid {
  address: String!
  amount: Decimal!

  """only an approx: first time this PDA was ingested"""
  createdAt: Timestamp!
  field: TCompField
  fieldId: String
  filledQuantity: Float!
  margin: String
  marginNr: Float
  ownerAddress: String!
  quantity: Float!
  solBalance: Decimal!
  target: TCompTarget!
  targetId: String!
}

input TCompBidFieldFilter {
  field: TCompField!
  fieldIds: [String!]!
}

type TCompBidUpdate {
  address: String!
  bid: TCompBid
}

type TCompBidUpdateAll {
  address: String!
  bid: TCompBidWithSlug
}

type TCompBidWithColl {
  bid: TCompBid!
  collInfo: CollInfo
  marginNr: Float
}

type TCompBidWithSlug {
  address: String!
  amount: Decimal!

  """only an approx: first time this PDA was ingested"""
  createdAt: Timestamp!
  field: TCompField
  fieldId: String
  filledQuantity: Float!
  margin: String
  marginNr: Float
  ownerAddress: String!
  quantity: Float!
  slug: String!
  solBalance: Decimal!
  target: TCompTarget!
  targetId: String!
}

input TCompBidsFilters {
  fields: [TCompBidFieldFilter!]

  """
  If true, excludes any bids that specify a field. Ignores `fields` if true.
  """
  noFields: Boolean
}

enum TCompField {
  NAME
}

enum TCompTarget {
  ASSET_ID
  WHITELIST
}

interface TLastSale {
  price: Decimal!
  priceUnit: Currency!
  txAt: Timestamp!
}

interface TLinkedTxMintTV2 {
  accState: String
  animationUri: String
  attributes: JSON
  compressed: Boolean!
  imageUri: String
  lastSale: LastSale
  metadataFetchedAt: Timestamp
  metadataUri: String
  name: String
  onchainId: String!
  owner: String
  rarityRankHR: Int
  rarityRankStat: Int
  rarityRankTN: Int
  rarityRankTT: Int
  rarityRankTTCustom: Int
  rarityRankTTStat: Int
  rarityRankTeam: Int
  sellRoyaltyFeeBPS: Int
  tokenEdition: Int
  tokenStandard: TokenStandard
  verifiedCollection: String
}

type TSwapMarginAccount {
  address: String!
  balance: BigInt!
  createdAt: Timestamp!
  currentActive: Boolean!
  name: String!
  nr: Int!
  owner: String!
  pendingActive: Boolean!
  poolsAttached: Int!
  slot: BigInt!
  updatedAt: Timestamp!
}

type TSwapMarginUpdate {
  address: String!
  margin: TSwapMarginAccount
}

type TSwapMintProof {
  address: String!
  createdAt: Timestamp!
  proof: [Byte!]!
  rootHash: Byte!
  slug: String!
  updatedAt: Timestamp!
}

type TSwapPool {
  address: String!
  balance: BigInt!
  buyNowPrice: Decimal
  createdAt: Timestamp!
  createdUnix: Timestamp!
  currentActive: Boolean!
  curveType: CurveType!
  delta: BigInt!

  """Only present when queried with tswapOrders for MintWithColl"""
  feeInfos: [FeeInfo!]
  frozenAmount: BigInt
  frozenTime: Timestamp
  isCosigned: Boolean!
  lastTransactedAt: Timestamp
  margin: String
  marginNr: Float
  maxTakerSellCount: Int!
  mmCompoundFees: Boolean!
  mmFeeBalance: BigInt!
  mmFeeBps: Int
  nftAuthorityAddress: String!
  nftsForSale: [LinkedTxMintTV2!]!
  nftsHeld: Int!
  orderType: Int!
  ownerAddress: String!
  pendingActive: Boolean!
  poolType: PoolType!
  sellNowPrice: Decimal

  """Only present when queried with tswapOrders for MintWithColl"""
  sellNowPriceNetFees: Decimal
  slot: BigInt!
  solBalance: BigInt!
  solEscrowAddress: String!
  startingPrice: BigInt!
  statsAccumulatedMmProfit: BigInt!
  statsTakerBuyCount: Int!
  statsTakerSellCount: Int!
  takerBuyCount: Int!
  takerSellCount: Int!
  updatedAt: Timestamp!
  version: Int!
  whitelistAddress: String!
}

type TSwapPoolUpdate {
  address: String!
  pool: TSwapPool
}

type TSwapPoolUpdateAll {
  address: String!
  pool: TSwapPoolWithSlug
}

type TSwapPoolWithColl {
  collName: String!
  floorPrice: Decimal
  marginNr: Float
  numMints: Int
  pool: TSwapPool!
  slug: String!
}

type TSwapPoolWithSlug {
  address: String!
  balance: BigInt!
  buyNowPrice: Decimal
  createdAt: Timestamp!
  createdUnix: Timestamp!
  currentActive: Boolean!
  curveType: CurveType!
  delta: BigInt!

  """Only present when queried with tswapOrders for MintWithColl"""
  feeInfos: [FeeInfo!]
  frozenAmount: BigInt
  frozenTime: Timestamp
  isCosigned: Boolean!
  lastTransactedAt: Timestamp
  margin: String
  marginNr: Float
  maxTakerSellCount: Int!
  mmCompoundFees: Boolean!
  mmFeeBalance: BigInt!
  mmFeeBps: Int
  nftAuthorityAddress: String!
  nftsForSale: [LinkedTxMintTV2!]!
  nftsHeld: Int!
  orderType: Int!
  ownerAddress: String!
  pendingActive: Boolean!
  poolType: PoolType!
  sellNowPrice: Decimal

  """Only present when queried with tswapOrders for MintWithColl"""
  sellNowPriceNetFees: Decimal
  slot: BigInt!
  slug: String!
  solBalance: BigInt!
  solEscrowAddress: String!
  startingPrice: BigInt!
  statsAccumulatedMmProfit: BigInt!
  statsTakerBuyCount: Int!
  statsTakerSellCount: Int!
  takerBuyCount: Int!
  takerSellCount: Int!
  updatedAt: Timestamp!
  version: Int!
  whitelistAddress: String!
}

type TSwapWhitelist {
  address: String!
  createdAt: Timestamp!
  frozen: Boolean!
  fvc: String
  name: String!
  rootHash: Byte!
  slot: BigInt!
  updatedAt: Timestamp!
  uuid: String!
  verified: Boolean!
  version: Int!
  voc: String
}

type TensorBidsV2 {
  bids: [MintBid!]!
  page: BidsPage!
  sortBy: BidsSortBy!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

enum TokenStandard {
  FUNGIBLE
  FUNGIBLE_ASSET
  NON_FUNGIBLE
  NON_FUNGIBLE_EDITION
  PROGRAMMABLE_NON_FUNGIBLE
}

enum TradeAction {
  ACCEPT
  BID
  BUY
  CANCEL
  DELIST
  DEPOSIT
  ELIXIR_APPRAISE
  INIT_UPDATE_MINT_PROOF
  LIST
  MARGIN_ATTACH
  MARGIN_CLOSE
  MARGIN_DEPOSIT
  MARGIN_DETACH
  MARGIN_INIT
  MARGIN_WITHDRAW
  SWAP_BUY_NFT
  SWAP_BUY_SINGLE_LISTING
  SWAP_CLOSE_POOL
  SWAP_DELIST
  SWAP_DEPOSIT_LIQ
  SWAP_DEPOSIT_NFT
  SWAP_DEPOSIT_SOL
  SWAP_EDIT_POOL
  SWAP_EDIT_SINGLE_LISTING
  SWAP_EXCHANGE_NFT
  SWAP_INIT_POOL
  SWAP_LIST
  SWAP_SELL_NFT
  SWAP_WITHDRAW_LIQ
  SWAP_WITHDRAW_MM_FEE
  SWAP_WITHDRAW_NFT
  SWAP_WITHDRAW_SOL
  WITHDRAW
}

input TraitCountFilter {
  min: Int
  max: Int
}

input TraitFilter {
  traitType: String!
  values: [String!]!
}

enum TransactionType {
  ADJUST_PRICE
  AUCTION_CANCEL
  AUCTION_CREATE
  AUCTION_PLACE_BID
  AUCTION_SETTLE
  CANCEL_BID
  CREATE_MINT
  DELIST
  ELIXIR_APPRAISE
  ELIXIR_BUY_PNFT
  ELIXIR_COMPOSED_BUY_NFT
  ELIXIR_COMPOSED_SELL_NFT
  ELIXIR_FRACTIONALIZE
  ELIXIR_FUSE
  ELIXIR_POOL_DEPOSIT_FNFT
  ELIXIR_POOL_EXCHANGE_FNFT
  ELIXIR_POOL_WITHDRAW_FNFT
  ELIXIR_SELL_PNFT
  FAILED
  LIST
  MARGIN_ATTACH
  MARGIN_CLOSE
  MARGIN_DEPOSIT
  MARGIN_DETACH
  MARGIN_INIT
  MARGIN_WITHDRAW
  OTHER
  PLACE_BID
  SALE_ACCEPT_BID
  SALE_BUY_NOW
  SWAP_BUY_NFT
  SWAP_BUY_SINGLE_LISTING
  SWAP_CLOSE_POOL
  SWAP_DELIST
  SWAP_DEPOSIT_LIQ
  SWAP_DEPOSIT_NFT
  SWAP_DEPOSIT_SOL
  SWAP_EDIT_POOL
  SWAP_EDIT_SINGLE_LISTING
  SWAP_INIT_POOL
  SWAP_LIST
  SWAP_SELL_NFT
  SWAP_WITHDRAW_LIQ
  SWAP_WITHDRAW_MM_FEE
  SWAP_WITHDRAW_NFT
  SWAP_WITHDRAW_SOL
  TRANSFER
  UPDATE_MINT
}

type TransactionsCursor {
  txAt: Timestamp!
  txKey: String!
}

input TransactionsCursorInput {
  txAt: Timestamp!
  txKey: String!
}

input TransactionsFilters {
  txTypes: [TransactionType!]
  mps: [DataSource!]

  """only relevant for recentTransactions"""
  prices: PriceFilter

  """only relevant for recentTransactions"""
  traits: [TraitFilter!]

  """only relevant for recentTransactions"""
  traitCount: TraitCountFilter
}

type TransactionsPage {
  endCursor: TransactionsCursor
  hasMore: Boolean!
}

type TxMetadata {
  auctionHouse: String
  pdaAddr: String
  sellerRef: String
  tokenAcc: String
  urlId: String
}

type TxResponse {
  """
  For some Tensor txs eg tswapBuyNftTx, this will be populated with the price including Tensor fees and royalties
  """
  totalPriceNetFees: Decimal
  txs: [OnchainTx!]!
}

type UserActiveListingsV2 {
  page: ActiveListingsPageV2!
  txs: [LinkedTransactionMintWithColl!]!
}

type UserDiscordPrivate {
  accessToken: String!
  expiresAt: Timestamp!
  profileId: String!
  refreshToken: String!
  userId: String!
}

type UserProfile {
  _count: UserProfileCount

  """null if didn't qualify for Tensor Aidrop 1"""
  airdropOne: AirdropOne

  """null if no Airdrop Two activity"""
  airdropTwo: AirdropTwoProfileStats
  bidNotifMinPctFloor: Int!
  claimedAirdropOneAt: Timestamp
  claimedAirdropTwoAt: Timestamp
  createdAt: Timestamp!
  discord: String
  discordJoined: Boolean!
  discordPrivate: UserDiscordPrivate
  email: String
  emailConfirmed: Boolean!
  favCollections: [CollectionFavorite!]!
  favMints: [MintFavorite!]!
  favWallets: [WalletFavorite!]!
  genesisWallet: String!
  id: String!
  loyaltyLevel: Int!
  madBoxes: [MadBox!]!
  openedNftBoxesAt: Timestamp
  twitter: String
  twitterFollowed: Boolean!
  twitterPrivate: UserTwitterPrivate
  updatedAt: Timestamp!
  username: String
  wallets: [UserWallet!]!
}

type UserProfileCount {
  favColls: Int!
  favMints: Int!
  favWallets: Int!
  transitions: Int!
  wallets: Int!
}

type UserProfileWithJwtV2 {
  jwt: String!
  profile: UserProfile!
}

type UserSentTransactionStats {
  past24h: SentTransactionStats!
  past30d: SentTransactionStats!
}

type UserTransaction {
  action: TradeAction!
  amounts: [Decimal!]
  attemptedAt: Timestamp!
  data: UserTxData!
  inflatedTx: JSON
  mints: [String!]
  mp: SupportedMarketplace
  poolAddresses: [String!]
  sig: String!
  status: UserTxStatus!
  wallet: String!
}

type UserTwitterPrivate {
  profileId: String!
  userId: String!
  v1AccessSecret: String
  v1AccessToken: String
  v2AccessToken: String
  v2ExpiresAt: Timestamp
  v2RefreshToken: String
}

type UserTxData {
  data: JSON!
  version: Int!
}

input UserTxDataInput {
  version: Int!
  data: JSON!
}

enum UserTxStatus {
  CONFIRMED
  FAILED
  FINALIZED
  PENDING
}

type UserWallet {
  _count: UserWalletCount
  createdAt: Timestamp!
  profileId: String!
  updatedAt: Timestamp!
  wallet: String!
}

type UserWalletCount {
  transitions: Int!
}

type WalletFavorite {
  address: String!
  favList: Int!
  profileId: String!
}